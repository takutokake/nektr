import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';

// Ensure Firebase Admin is initialized
if (admin.apps.length === 0) {
  admin.initializeApp();
}

const db = admin.firestore();

export const autoGenerateDropMatches = functions.pubsub
  .schedule('every 5 minutes')
  .onRun(async (context) => {
    try {
      // Get current timestamp
      const now = admin.firestore.Timestamp.now();

      // Query for drops that are ready to be matched
      const dropsQuery = await db.collection('drops')
        .where('status', '==', 'upcoming')
        .where('startTime', '<=', now)
        .get();

      // Process each drop
      const matchPromises = dropsQuery.docs.map(async (dropDoc) => {
        const dropData = dropDoc.data();
        const dropId = dropDoc.id;

        // Check if match already exists
        const existingMatchQuery = await db.collection('matches')
          .where('dropId', '==', dropId)
          .get();

        if (existingMatchQuery.empty) {
          // Fetch participants for this drop
          const participantsSnapshot = await db.collection('dropParticipants')
            .doc(dropId)
            .get();

          const participantsData = participantsSnapshot.data();
          
          if (participantsData && participantsData.participants) {
            const participantIds = Object.keys(participantsData.participants);
            
            // Randomly shuffle participants
            const shuffledParticipants = participantIds.sort(() => 0.5 - Math.random());
            const matchPairs: { [key: string]: string } = {};

            // Create match pairs
            for (let i = 0; i < shuffledParticipants.length; i += 2) {
              if (shuffledParticipants[i + 1]) {
                const user1 = shuffledParticipants[i];
                const user2 = shuffledParticipants[i + 1];
                
                matchPairs[user1] = user2;
                matchPairs[user2] = user1;
              }
            }

            // Create match document
            const matchRef = db.collection('matches').doc();
            await matchRef.set({
              id: matchRef.id,
              dropId: dropId,
              matchPairs,
              status: 'pending',
              createdAt: now
            });

            // Send notifications to each participant
            const notificationPromises = Object.entries(matchPairs).map(
              async ([userId, matchedUserId]) => {
                await db.collection('notifications').add({
                  userId: userId,
                  title: 'Drop Match Generated',
                  body: `You have been matched for a drop!`,
                  data: {
                    dropId: dropId,
                    matchedUserId: matchedUserId,
                    matchId: matchRef.id
                  },
                  read: false,
                  createdAt: now
                });
              }
            );

            // Wait for all notifications to be sent
            await Promise.all(notificationPromises);

            // Update drop status
            await db.collection('drops').doc(dropId).update({
              status: 'matched',
              updatedAt: now
            });

            console.log(`Matched participants for drop ${dropId}`);
          }
        }
      });

      // Wait for all drops to be processed
      await Promise.all(matchPromises);

      return null;
    } catch (error) {
      console.error('Error in autoGenerateDropMatches:', error);
      return null;
    }
  });

// HTTP-callable function for manual trigger (optional)
export const manualDropMatchTrigger = functions.https.onCall(async (data, context) => {
  try {
    // Optional: Add admin check
    // if (!context.auth || !context.auth.token.admin) {
    //   throw new functions.https.HttpsError('permission-denied', 'Must be an admin');
    // }

    const now = admin.firestore.Timestamp.now();
    const dropsQuery = await db.collection('drops')
      .where('status', '==', 'upcoming')
      .get();

    const matchPromises = dropsQuery.docs.map(async (dropDoc) => {
      const dropId = dropDoc.id;
      
      // Similar matching logic as above
      // ... (copy the matching logic from the pubsub function)
    });

    await Promise.all(matchPromises);

    return { 
      success: true, 
      message: 'Manual drop match generation completed' 
    };
  } catch (error) {
    console.error('Error in manual drop match trigger:', error);
    throw new functions.https.HttpsError('internal', 'Failed to generate drop matches');
  }
});
